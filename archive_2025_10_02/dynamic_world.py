"""
SSD Village Simulation - Dynamic World System
4層物理構造SSDに対応した動的・創発的世界システム
"""

import random
import math
from collections import defaultdict, deque
from dataclasses import dataclass
from typing import Dict, List, Tuple, Optional
from enum import Enum


class WorldEventType(Enum):
    """世界イベントの種類"""
    RESOURCE_DISCOVERY = "resource_discovery"
    CLIMATE_SHIFT = "climate_shift"
    MIGRATION_PRESSURE = "migration_pressure"
    TECHNOLOGICAL_CATALYST = "technological_catalyst"
    SOCIAL_TENSION = "social_tension"
    ENVIRONMENTAL_CRISIS = "environmental_crisis"
    ECOSYSTEM_EVOLUTION = "ecosystem_evolution"


@dataclass
class WorldEvent:
    """世界イベントクラス"""
    event_type: WorldEventType
    location: Tuple[int, int]
    duration: int
    intensity: float
    affected_radius: int
    consequences: Dict[str, float]
    trigger_conditions: Dict[str, float]


class AdaptiveEcosystem:
    """適応的生態系システム - NPCの活動に応じて進化"""
    
    def __init__(self, world_size: int):
        self.world_size = world_size
        self.resource_pressure_map = {}  # 位置ごとの資源圧力
        self.ecosystem_memory = deque(maxlen=100)  # 過去のエコシステム状態
        self.adaptation_rate = 0.05
        
        # 生態系パラメータ
        self.biodiversity_index = 1.0
        self.resource_regeneration_rate = 1.0
        self.predator_prey_balance = 1.0
        self.environmental_stress = 0.0
        
        # 地域特性マップ
        self.terrain_fertility = self._generate_terrain_fertility()
        self.water_table_depth = self._generate_water_table()
        self.mineral_deposits = self._generate_mineral_deposits()
        
    def _generate_terrain_fertility(self) -> Dict[Tuple[int, int], float]:
        """地形肥沃度マップ生成"""
        fertility_map = {}
        # パーリンノイズ風の地形生成
        for x in range(0, self.world_size, 5):\n            for y in range(0, self.world_size, 5):\n                # 複数の周波数を重ね合わせ\n                fertility = 0.5\n                fertility += 0.3 * math.sin(x * 0.1) * math.cos(y * 0.1)\n                fertility += 0.2 * math.sin(x * 0.05) * math.sin(y * 0.08)\n                fertility = max(0.1, min(1.0, fertility))\n                fertility_map[(x, y)] = fertility\n        return fertility_map
    
    def _generate_water_table(self) -> Dict[Tuple[int, int], float]:
        \"\"\"地下水位マップ生成\"\"\"\n        water_table = {}\n        # 河川システムのシミュレーション\n        for x in range(0, self.world_size, 3):\n            for y in range(0, self.world_size, 3):\n                # 地形に基づく水位\n                elevation = abs(math.sin(x * 0.02) * math.cos(y * 0.03))\n                water_depth = 1.0 - elevation + random.uniform(-0.2, 0.2)\n                water_depth = max(0.1, min(1.0, water_depth))\n                water_table[(x, y)] = water_depth\n        return water_table
    
    def _generate_mineral_deposits(self) -> Dict[Tuple[int, int], Dict[str, float]]:
        \"\"\"鉱物資源分布生成\"\"\"\n        deposits = {}\n        mineral_types = ['stone', 'clay', 'metal_ore', 'precious_stone']\n        \n        for x in range(0, self.world_size, 8):\n            for y in range(0, self.world_size, 8):\n                local_deposits = {}\n                for mineral in mineral_types:\n                    # 各鉱物の分布パターン\n                    concentration = random.random()\n                    if mineral == 'stone':\n                        concentration += 0.3  # 石は豊富\n                    elif mineral == 'precious_stone':\n                        concentration *= 0.1  # 貴石は希少\n                    \n                    local_deposits[mineral] = max(0.0, min(1.0, concentration))\n                deposits[(x, y)] = local_deposits\n        return deposits
    
    def respond_to_npc_activity(self, npc_activities: List[Dict], current_tick: int):\n        \"\"\"NPC活動に対するエコシステムの応答\"\"\"\n        # 活動パターンの分析\n        activity_patterns = self._analyze_activity_patterns(npc_activities)\n        \n        # 資源圧力の更新\n        self._update_resource_pressure(activity_patterns)\n        \n        # 生態系パラメータの調整\n        self._adjust_ecosystem_parameters(activity_patterns)\n        \n        # 新しい環境機会の生成\n        self._generate_environmental_opportunities(activity_patterns, current_tick)\n        \n        # エコシステム記憶への追加\n        self.ecosystem_memory.append({\n            'tick': current_tick,\n            'biodiversity': self.biodiversity_index,\n            'stress': self.environmental_stress,\n            'activities': len(npc_activities)\n        })\n    \n    def _analyze_activity_patterns(self, activities: List[Dict]) -> Dict[str, float]:\n        \"\"\"NPC活動パターンの分析\"\"\"\n        patterns = defaultdict(float)\n        \n        for activity in activities:\n            action_type = activity.get('action', 'unknown')\n            location = activity.get('location', (0, 0))\n            success = activity.get('success', False)\n            \n            # 活動密度の計算\n            patterns[f'{action_type}_frequency'] += 1.0\n            patterns[f'{action_type}_success_rate'] += 1.0 if success else 0.0\n            \n            # 地域的な活動圧力\n            region_key = f'region_{location[0]//10}_{location[1]//10}'\n            patterns[f'{region_key}_pressure'] += 0.1\n            \n            # 特定活動の環境への影響\n            if action_type == 'foraging':\n                patterns['foraging_pressure'] += 0.05\n            elif action_type == 'hunting':\n                patterns['hunting_pressure'] += 0.1\n            elif action_type == 'exploration':\n                patterns['exploration_expansion'] += 0.02\n        \n        return dict(patterns)\n    \n    def _update_resource_pressure(self, patterns: Dict[str, float]):\n        \"\"\"資源圧力マップの更新\"\"\"\n        # 採集圧力による資源枯渇\n        foraging_pressure = patterns.get('foraging_pressure', 0.0)\n        self.resource_regeneration_rate *= (1.0 - foraging_pressure * 0.1)\n        self.resource_regeneration_rate = max(0.5, min(1.5, self.resource_regeneration_rate))\n        \n        # 狩猟圧力による生態系バランス変化\n        hunting_pressure = patterns.get('hunting_pressure', 0.0)\n        self.predator_prey_balance *= (1.0 - hunting_pressure * 0.05)\n        self.predator_prey_balance = max(0.3, min(2.0, self.predator_prey_balance))\n    \n    def _adjust_ecosystem_parameters(self, patterns: Dict[str, float]):\n        \"\"\"生態系パラメータの動的調整\"\"\"\n        # 生物多様性の変化\n        exploration_expansion = patterns.get('exploration_expansion', 0.0)\n        if exploration_expansion > 0.1:\n            self.biodiversity_index += 0.02  # 探索により新種発見\n        \n        # 環境ストレスの計算\n        total_pressure = sum(v for k, v in patterns.items() if 'pressure' in k)\n        self.environmental_stress = min(1.0, total_pressure * 0.1)\n        \n        # 自然回復\n        self.biodiversity_index = min(1.0, self.biodiversity_index + 0.001)\n        self.environmental_stress *= 0.99\n    \n    def _generate_environmental_opportunities(self, patterns: Dict[str, float], tick: int):\n        \"\"\"環境機会の動的生成\"\"\"\n        # 高い探索活動 → 新資源発見の機会\n        if patterns.get('exploration_expansion', 0.0) > 0.05:\n            return self._create_discovery_opportunity(tick)\n        \n        # 高い環境ストレス → 気候変動イベント\n        if self.environmental_stress > 0.7:\n            return self._create_crisis_event(tick)\n        \n        # 低い生物多様性 → 生態系復活イベント\n        if self.biodiversity_index < 0.5:\n            return self._create_recovery_event(tick)\n    \n    def get_regional_conditions(self, location: Tuple[int, int]) -> Dict[str, float]:\n        \"\"\"指定地域の環境条件取得\"\"\"\n        # 最寄りのデータポイントから補間\n        fertility = self._interpolate_fertility(location)\n        water_access = self._interpolate_water_access(location)\n        mineral_richness = self._interpolate_mineral_richness(location)\n        \n        return {\n            'fertility': fertility,\n            'water_access': water_access,\n            'mineral_richness': mineral_richness,\n            'biodiversity': self.biodiversity_index,\n            'environmental_stress': self.environmental_stress,\n            'resource_regeneration': self.resource_regeneration_rate\n        }
    
    def _interpolate_fertility(self, location: Tuple[int, int]) -> float:\n        \"\"\"肥沃度の補間計算\"\"\"\n        x, y = location\n        # 最寄りの4点から補間\n        x_base, y_base = (x // 5) * 5, (y // 5) * 5\n        nearby_points = [\n            (x_base, y_base),\n            (x_base + 5, y_base),\n            (x_base, y_base + 5),\n            (x_base + 5, y_base + 5)\n        ]\n        \n        total_weight = 0.0\n        weighted_fertility = 0.0\n        \n        for point in nearby_points:\n            if point in self.terrain_fertility:\n                distance = max(1.0, math.sqrt((x - point[0])**2 + (y - point[1])**2))\n                weight = 1.0 / distance\n                weighted_fertility += self.terrain_fertility[point] * weight\n                total_weight += weight\n        \n        return weighted_fertility / total_weight if total_weight > 0 else 0.5
    
    def _interpolate_water_access(self, location: Tuple[int, int]) -> float:\n        \"\"\"水アクセスの補間計算\"\"\"\n        x, y = location\n        x_base, y_base = (x // 3) * 3, (y // 3) * 3\n        \n        if (x_base, y_base) in self.water_table_depth:\n            return self.water_table_depth[(x_base, y_base)]\n        \n        # 近傍点の平均\n        nearby_values = []\n        for dx in [-3, 0, 3]:\n            for dy in [-3, 0, 3]:\n                point = (x_base + dx, y_base + dy)\n                if point in self.water_table_depth:\n                    nearby_values.append(self.water_table_depth[point])\n        \n        return sum(nearby_values) / len(nearby_values) if nearby_values else 0.5
    
    def _interpolate_mineral_richness(self, location: Tuple[int, int]) -> float:\n        \"\"\"鉱物豊富度の補間計算\"\"\"\n        x, y = location\n        x_base, y_base = (x // 8) * 8, (y // 8) * 8\n        \n        if (x_base, y_base) in self.mineral_deposits:\n            deposits = self.mineral_deposits[(x_base, y_base)]\n            return sum(deposits.values()) / len(deposits)\n        \n        return 0.3  # デフォルト値


class WorldEventSystem:
    \"\"\"世界イベントシステム - NPCの発達段階に応じたイベント生成\"\"\"\n    \n    def __init__(self, world_size: int):\n        self.world_size = world_size\n        self.active_events = []\n        self.event_history = []\n        self.civilization_level = 0.0  # 文明発達度\n        \n    def assess_civilization_level(self, npcs: List) -> float:\n        \"\"\"文明発達度の評価\"\"\"\n        if not npcs:\n            return 0.0\n        \n        # 人口密度\n        population_factor = min(1.0, len([npc for npc in npcs if npc.alive]) / 20.0)\n        \n        # 技術レベル（経験値の平均）\n        avg_experience = sum(sum(npc.experience.values()) for npc in npcs if npc.alive) / len([npc for npc in npcs if npc.alive])\n        tech_factor = min(1.0, avg_experience / 10.0)\n        \n        # 社会組織（テリトリー形成）\n        territories = len(set(npc.territory.name for npc in npcs if npc.alive and npc.territory))\n        social_factor = min(1.0, territories / 5.0)\n        \n        self.civilization_level = (population_factor + tech_factor + social_factor) / 3.0\n        return self.civilization_level\n    \n    def generate_contextual_events(self, npcs: List, ecosystem: AdaptiveEcosystem, tick: int):\n        \"\"\"文脈に応じたイベント生成\"\"\"\n        civ_level = self.assess_civilization_level(npcs)\n        \n        # 文明レベルに応じたイベント確率\n        if civ_level < 0.3:  # 原始段階\n            self._generate_survival_events(npcs, ecosystem, tick)\n        elif civ_level < 0.6:  # 発展段階\n            self._generate_development_events(npcs, ecosystem, tick)\n        else:  # 高度段階\n            self._generate_complex_events(npcs, ecosystem, tick)\n        \n        # イベントの更新\n        self._update_active_events(tick)\n    \n    def _generate_survival_events(self, npcs: List, ecosystem: AdaptiveEcosystem, tick: int):\n        \"\"\"生存段階のイベント生成\"\"\"\n        if random.random() < 0.02:  # 2%の確率\n            event_types = [\n                self._create_resource_scarcity_event,\n                self._create_predator_increase_event,\n                self._create_weather_change_event\n            ]\n            event_creator = random.choice(event_types)\n            event = event_creator(npcs, tick)\n            if event:\n                self.active_events.append(event)\n    \n    def _generate_development_events(self, npcs: List, ecosystem: AdaptiveEcosystem, tick: int):\n        \"\"\"発展段階のイベント生成\"\"\"\n        if random.random() < 0.015:  # 1.5%の確率\n            event_types = [\n                self._create_technology_catalyst_event,\n                self._create_territorial_conflict_event,\n                self._create_resource_discovery_event\n            ]\n            event_creator = random.choice(event_types)\n            event = event_creator(npcs, tick)\n            if event:\n                self.active_events.append(event)\n    \n    def _generate_complex_events(self, npcs: List, ecosystem: AdaptiveEcosystem, tick: int):\n        \"\"\"高度段階のイベント生成\"\"\"\n        if random.random() < 0.01:  # 1%の確率\n            event_types = [\n                self._create_social_revolution_event,\n                self._create_environmental_crisis_event,\n                self._create_migration_wave_event\n            ]\n            event_creator = random.choice(event_types)\n            event = event_creator(npcs, tick)\n            if event:\n                self.active_events.append(event)\n    \n    def _create_resource_discovery_event(self, npcs: List, tick: int) -> Optional[WorldEvent]:\n        \"\"\"新資源発見イベント\"\"\"\n        # 探索活動が多い地域で発生\n        exploration_activities = [npc for npc in npcs if npc.exploration_mode and npc.alive]\n        if not exploration_activities:\n            return None\n        \n        explorer = random.choice(exploration_activities)\n        location = explorer.pos()\n        \n        return WorldEvent(\n            event_type=WorldEventType.RESOURCE_DISCOVERY,\n            location=location,\n            duration=50,\n            intensity=0.8,\n            affected_radius=15,\n            consequences={\n                'resource_abundance': 1.5,\n                'exploration_motivation': 0.3,\n                'settlement_attractiveness': 0.4\n            },\n            trigger_conditions={'exploration_pressure': 0.6}\n        )\n    
n    def get_environmental_pressure_at(self, location: Tuple[int, int]) -> float:\n        \"\"\"指定地点の環境圧力計算\"\"\"\n        total_pressure = 0.0\n        \n        for event in self.active_events:\n            distance = math.sqrt((location[0] - event.location[0])**2 + (location[1] - event.location[1])**2)\n            if distance <= event.affected_radius:\n                # 距離による圧力減衰\n                pressure_factor = 1.0 - (distance / event.affected_radius)\n                event_pressure = event.intensity * pressure_factor\n                \n                # イベントタイプによる圧力調整\n                if event.event_type == WorldEventType.ENVIRONMENTAL_CRISIS:\n                    event_pressure *= 2.0\n                elif event.event_type == WorldEventType.RESOURCE_DISCOVERY:\n                    event_pressure *= -0.5  # 正の効果\n                \n                total_pressure += event_pressure\n        \n        return max(0.0, min(2.0, total_pressure))\n\n\nclass DynamicWorldSystem:\n    \"\"\"統合的な動的世界システム\"\"\"\n    \n    def __init__(self, world_size: int = 90):\n        self.world_size = world_size\n        self.ecosystem = AdaptiveEcosystem(world_size)\n        self.event_system = WorldEventSystem(world_size)\n        \n        # 既存環境システムとの統合\n        self.weather = None\n        self.day_night = None\n        self.predators = []\n        self.prey_animals = []\n        \n        # リソースマップ（動的生成・更新）\n        self.dynamic_resources = self._initialize_dynamic_resources()\n        \n    def _initialize_dynamic_resources(self) -> Dict[str, Dict[str, float]]:\n        \"\"\"動的リソースマップの初期化\"\"\"\n        resources = {\n            'water_sources': {},\n            'berry_patches': {},\n            'hunting_grounds': {},\n            'mineral_sites': {},\n            'cave_systems': {}\n        }\n        \n        # エコシステムデータに基づいて初期リソース配置\n        for x in range(0, self.world_size, 10):\n            for y in range(0, self.world_size, 10):\n                location = (x, y)\n                conditions = self.ecosystem.get_regional_conditions(location)\n                \n                # 水源の配置（水アクセスが高い場所）\n                if conditions['water_access'] > 0.7:\n                    resources['water_sources'][f'water_{x}_{y}'] = {\n                        'location': location,\n                        'abundance': conditions['water_access'],\n                        'quality': random.uniform(0.5, 1.0)\n                    }\n                \n                # ベリー園（肥沃度が高い場所）\n                if conditions['fertility'] > 0.6:\n                    resources['berry_patches'][f'berry_{x}_{y}'] = {\n                        'location': location,\n                        'abundance': conditions['fertility'] * conditions['resource_regeneration'],\n                        'growth_rate': conditions['fertility']\n                    }\n        \n        return resources\n    \n    def integrate_with_npc_cognition(self, npcs: List, tick: int):\n        \"\"\"NPCの4層認知システムとの統合\"\"\"\n        # NPCの活動データ収集\n        npc_activities = self._collect_npc_activities(npcs)\n        \n        # エコシステムの応答\n        self.ecosystem.respond_to_npc_activity(npc_activities, tick)\n        \n        # イベントシステムの更新\n        self.event_system.generate_contextual_events(npcs, self.ecosystem, tick)\n        \n        # 各NPCに環境フィードバックを提供\n        self._provide_environmental_feedback(npcs)\n    \n    def _collect_npc_activities(self, npcs: List) -> List[Dict]:\n        \"\"\"NPCの活動データ収集\"\"\"\n        activities = []\n        for npc in npcs:\n            if npc.alive and npc.log:\n                recent_activities = npc.log[-5:]  # 直近5アクション\n                for activity in recent_activities:\n                    activities.append({\n                        'npc_name': npc.name,\n                        'action': activity.get('action', 'unknown'),\n                        'location': npc.pos(),\n                        'success': activity.get('success', False),\n                        'tick': activity.get('t', 0)\n                    })\n        return activities\n    \n    def _provide_environmental_feedback(self, npcs: List):\n        \"\"\"NPCへの環境フィードバック提供\"\"\"\n        for npc in npcs:\n            if npc.alive:\n                location = npc.pos()\n                \n                # 地域環境条件\n                regional_conditions = self.ecosystem.get_regional_conditions(location)\n                \n                # 環境圧力\n                environmental_pressure = self.event_system.get_environmental_pressure_at(location)\n                \n                # NPC の物理構造システムに環境データを提供\n                if hasattr(npc, 'physical_system') and npc.physical_system:\n                    # 4層構造での環境情報統合\n                    environmental_stimuli = {\n                        'environmental_pressure': environmental_pressure,\n                        'resource_availability': regional_conditions['fertility'],\n                        'water_stress': 1.0 - regional_conditions['water_access'],\n                        'ecosystem_health': regional_conditions['biodiversity'],\n                        'climate_stability': 1.0 - regional_conditions['environmental_stress']\n                    }\n                    \n                    # 物理層での環境制約として統合\n                    if hasattr(npc.physical_system.physical_layer, 'update_environmental_constraints'):\n                        npc.physical_system.physical_layer.update_environmental_constraints(environmental_stimuli)\n    \n    def get_world_state_summary(self) -> Dict[str, float]:\n        \"\"\"世界状態のサマリー取得\"\"\"\n        return {\n            'civilization_level': self.event_system.civilization_level,\n            'biodiversity_index': self.ecosystem.biodiversity_index,\n            'environmental_stress': self.ecosystem.environmental_stress,\n            'resource_regeneration_rate': self.ecosystem.resource_regeneration_rate,\n            'active_events': len(self.event_system.active_events),\n            'ecosystem_memory_size': len(self.ecosystem.ecosystem_memory)\n        }


# 使用例とテスト関数
def test_dynamic_world_integration():
    \"\"\"動的世界システムのテスト\"\"\"\n    print(\"Dynamic World System Integration Test\")\n    print(\"=\" * 50)\n    \n    # 動的世界システム初期化\n    world = DynamicWorldSystem(world_size=90)\n    \n    # 初期状態表示\n    initial_state = world.get_world_state_summary()\n    print(f\"Initial World State: {initial_state}\")\n    \n    # サンプルNPC活動のシミュレーション\n    sample_activities = [\n        {'npc_name': 'Alice', 'action': 'exploration', 'location': (30, 40), 'success': True, 'tick': 100},\n        {'npc_name': 'Bob', 'action': 'foraging', 'location': (35, 45), 'success': True, 'tick': 101},\n        {'npc_name': 'Charlie', 'action': 'hunting', 'location': (25, 50), 'success': False, 'tick': 102}\n    ]\n    \n    # エコシステム応答のテスト\n    world.ecosystem.respond_to_npc_activity(sample_activities, 100)\n    \n    # 地域条件の確認\n    location = (30, 40)\n    conditions = world.ecosystem.get_regional_conditions(location)\n    print(f\"\\nRegional conditions at {location}: {conditions}\")\n    \n    print(\"\\nTest completed successfully!\")\n\n\nif __name__ == \"__main__\":\n    test_dynamic_world_integration()